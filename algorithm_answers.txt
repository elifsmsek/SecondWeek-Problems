A) Temel Türler & Null Güvenliği

1) `val` ile `var` arasındaki fark nedir?

`var` degiskenler, her seferinde degistirebildigimiz degiskenlerdir ancak `val` degeri yalnizca okunabilen set edilemeyen degiskenlerdir.


2) Bir `var` değişkeni `val` gibi davranmasını nasıl sağlayabiliriz `val` kelimesini kullanmadan? Bunu neden yapmak isteriz? Örnek bir senaryo verin.

`var` ile`val` arasindaki performans farki yok denecek kadar az olmasina ragmen(multithread kullandigimizda val daha performansli kaliyor) `val` daha maaliyetlidir. Bundan dolayi direkt val kullanmak yerine eger var`in set`ini private yaparsam benim icin daha uygundur ayrica bu sayede class`in icine bu degerin deger atamasini sonradan yapmak isteyebilirim bu yuzden `var` olmasi zorunludur ancak bu class`in disinda degerin baska yerde degismesini istemeyebilirim. 
	ex:
		 class UserFile{
		var fileName:String ="Elifs"
		private set

		fun user_account(){
		fileName = "elifsimsek12"
		}
	       }


3) "Değişmez" (Immutable) ve "Salt Okunur" (ReadOnly) kavramlarını açıklayın. `val` değişkenler neden aslında "değişmez" değil de "salt okunur" olarak açıklanmalıdır?

Immutable, degeri asla degismeyen degiskendir. ReadOnly ise degeri yalnizca okunabilen set edilemeyen degiskendir. "val"in da readOnly olmasinin sebebi icerisinde degistirebilir degiskenleri(var yapisindaki) icerebilir olmasidir.

4) "Tip Çıkarımı" (Type inference) kavramını açıklayın. Hangi durumlarda tip belirtmek kesin olarak gereklidir?

Bir esitlik olusturdugumuzda esitligin karsi tarafina atadigimiz degerin tipini vermesek bile IDE`nin degisken tipini belirlemesidir.Genellikle kodumuzun netligini saglayarak diger developerlar icin de daha anlasilabilirligini saglamak icin kullaniriz.Ornegin biz bir  " var sira " tanimladigimizda sira sayisinin int ile tanimlanmasini biz bilmemize ragmen IDE bunu bilemez ve ayrica diger developerlar icin de bir anlam karisikligina sebep olabilir.

5) Kotlin'de tüm değişkenlerin sınıf olarak bulunması, "ilkel tip" (primitive type) olmadıkları anlamına gelir mi? Arka planda neler oluyor?

Kotlin`de primitive olarak bildigimiz class gibi gozuken degisken turleri, ozel optimasyonlarla bytecode`a cevrilirken yine primitive olarak cevriliyorlar.(Bu bir tip donusumu degil ki aslinda Kotlin `de nesne tabanli bir programlama tipi oldugu icin dusununce bu sekilde olmasi da mantikli bir hal aliyor.)

6) "Tip Güvenliği" (Type Safety) kavramını açıklayın.

Degiskenlerin ve ifadelerin turlerini derleme zamaninda kontrol eder ve turlerin birbirleriyle karslastirilmasi durumunda error verir.Ayni zamanda nullSafety de saglayarak NullPointerException gibi hatalari onler ve ayrica uygun kosullarda degiskenlerin turuni de otomatik olarak gosterebilir.

7) Bir değişkeni nullable yapmak için ne yapmalıyız?

Nullable aslinda deger alabilir ya da almayabilir anlamina gelmektedir.Nullable yapabilmek icin de "?" koymamiz yeterlidir.

8) "Null Güvenliği" (Null Safety) kavramını açıklayın.

Null Safety, null referans hatalarını önlemek veya azaltmak için kullanılir ve null guvenligi bazi ozelliklere gore saglanir.
	Bunlar Nullable(null olabilen) ve Non-nullable(null olamayan) turler, nullable bir değişkene erişilmeden önce null kontrolü yapılması ve  null güvenliğini sağlamak için ?., ?:, !!. gibi operatörler sağlar. Bu operatörlerle null değerlerin güvenli bir şekilde kullanılması ve kontrol edilmesi sağlanır.

9) Bir değişkene null değer atanır ve tip belirtilmezse Kotlin bu değişkeni nasıl yorumlar?
Eger bir degiskenin tipi belirtilmeksizin "null" deger atiyorsak bu "Nothing" alir.(degisken tipi =Nothing`dir) 
	Ex: 
		val number:Nothing?=null

10) İlkel bir değişkenin nullable olması ile null değer alamaması arasında bellek yönetimi açısından nasıl farklar vardır?

 Non-nullable ilkel değişkenler, daha az bellek kullanımı ve daha basit bellek yönetimi sağlarken, nullable ilkel değişkenler daha fazla bellek kullanımı ve karmaşıklık getirebilir. Bu nedenle, non-nullable değişkenlerin kullanımı genellikle tercih edilir, ancak bazı durumlarda nullable değişkenlerin ihtiyacı karşılaması gerekebilir.

11) Nullable bir değişkenin bir değere sahip olması ile null olması arasında bellek yönetimi açısından nasıl bir fark vardır? Null değer almış bir değişken bellekte yer kaplamaz diyebilir miyiz?

Bir degisken primitive olsa bile "nullable?" bir deger aliyorsa, bu degiskenin class hali anlamini tasiyor.
		- Degiskenin kapladigi alani, 
		-Erisim hizinin degistirir.
		-Referans kontrolunde farkli sonuc almamiza neden olur.
12) Nullable bir değişkenle çalışırken hangi operatörleri kullanırız? Bu operatörlerin kullanım farkları nelerdir? Hangisini ne zaman kullanmak daha anlamlıdır?

 Nullable bir değişkenin null olup olmadığını kontrol etmek için null operatörü kullanılır. Bu operatör, değişkenin null olup olmadığını belirler ve buna göre işlem yapmamızı sağlar. 
		val str: String? = null
		if (str != null) {
   	 		println(str.length) 
		}

Elvis operatörü, nullable bir değişkenin null olması durumunda varsayılan bir değer atamak için kullanılır. Bu operatör, değişkenin null olup olmadığını kontrol eder; null ise, belirtilen varsayılan değeri döndürür.

		val strLength = str?.length ?: 4

Safe call operatörü, nullable bir değişkene güvenli bir şekilde erişmek için kullanılır. Bu operatör, değişken null değilse, normal şekilde erişimi sağlar; ancak değişken null ise, hemen null döndürür ve sonraki işlemleri engeller.
		val strLength = str?.length


B) Sayılar	

1) Kaç farklı tipte "number" sınıfı miras alan "alt sınıf" (child class) vardır? Bunların değer aralıkları neden önemlidir?

 Kotlin'deki "number" sınıfını miras alan alt sınıflar arasında genellikle dört temel tip bulunmaktadır: Byte, Short, Int ve Long.Bunlarin deger araliklarinin onemli olmasinin sebebi programimiza ihtiyaclarina uygun olarak performans,bellek kullanimi ve dogrulugu acisindan kritiktir. 

2) Eğer bir değişkene tip belirtimi yapılmaz ve bir değer atanırsa, Kotlin tip çıkarımını nasıl yapar?

Type inference sayesinde esitligin,IDE otomatik bir sekilde esitligin sag tarafina bakarak degiskenin tipini belirlemesi ama sayisal degerler icin.

3) Float değişken oluştururken `F` ve `f` harfleri varken, Long değişken oluştururken neden küçük `l` harfi yoktur?

Cunku Long degisenlerde `l` kullanimi kodumuzu yazarken anlam karisikligina ve kodun iyi bir sekilde anlasilamamasina sebep olabilir.(1 veya `I`gibi anlasilabilir.)

4) Tek duyarlıklı (Single precision) ve Çift duyarlıklı (Double precision) kavramlarını açıklayın.

Bunlarin ikisi de ondalikli sayilari temsil etmek icin kullanilsa da Single precision yani float kavrami 32 bitlik bir veri turu olup ondalikli kesirleri daha kabaca yani küçük hassasiyet gerektiren durumlar için kullanılırken, Double precision yani double kavrami ise 64 bitlik bir veri turu olup daha yüksek hassasiyet ve daha geniş bir değer aralığı gerektiren durumlar için kullanılır.

5) Double ve Float değişkenlerle çalışırken ondalık ayıracı olarak hangi işaretler kullanılır? Bu ayıraçların kullanımında nelere dikkat etmek gerekir?

Ikisinde de nokta (.) kullanilmasina ragmen dikkat edilmesi gerekilen yer, uygulamamizi yaparken hangi dili baz alarak yazdigimizdir.Yani ornegin,yurt disindan dolar gibi para birimlerini kullanarak bir app gelistiriyorsak ondalik ayiraci olarak oranin kurallarina ozgun olarak nokta(.) kullanmamiz gerekirken , Turkiye`de ondalik ayiraci yaparken virgul kullanmamizdir ve bu uygulamamizin crash olmasina sebep olabilir:) .

6) Double ve Float değişkenler ondalık kısımda kaç basamağa kadar işlem yaparlar? Bu sınırın üzerinde gelen ondalık bilgileri için nasıl davranırlar?

Double veri tipi, 15-16 basamağa kadar kesinlik sağlar.
Float veri tipi ise, 6-7 basamağa kadar kesinlik sağlar.

Ancak burada onemli olan sınırlarin üzerinde gelen ondalık bilgileri icin yuvarlama ve kesme islemine ugrarlar.Dolayısıyla, ondalık kısımda çok büyük veya çok küçük değerlerle çalışırken, veri tiplerinin sınırlarını göz önünde bulundurmak ve bu sınırları aşan değerlerin nasıl işleneceğini anlamak önemlidir.

7) Ondalık(Decimal), Onaltılık (Hexadecimal) ve İkilik (Binary) değişkenleri Kotlin'de nasıl tanımlayabilirsiniz?

 Ondalık(Decimal):

	Kotlin'de varsayılan olarak ondalık sayıları anladığı bir sayı biçimi var oldugundan Ondalık(Decimal) sayilarda Int veya Double gibi veri tiplerini direktmen herhangi bir on ek eklemeden kullanilabilir.

Ornek: val pi :Double= 3.14159

 Onaltılık (Hexadecimal):
	
	Onaltılık sayılar, "0x" veya "0X" ön ekini kullanarak tanımlanır ve hexadecimal sayı sistemindeki değerleri ifade ederler.

Ornek: val hexNumber: Int = 0x2A //2A(16 tabaninda 42) degerini temsil eder.

 İkilik (Binary):

	İkilik sayılar, "0b" veya "0B" ön ekini kullanarak tanımlanır ve binary sayı sistemindeki değerleri ifade ederler.

Ornek: val binaryNumber: Int = 0b101010 //101010 (2 tabanında 42) değerini temsil eder.

8) Sekizlik (Octal) değişkenler Java'da nasıl tanımlanır? Kotlin'de Sekizlik değişken tanımlanabilir mi?

	Java`da tanimlarken asdece basina 0 eklemeliyizdir.Depolama icin kullanilan veri tipi int `tir.

 Yöntem(Parameters): Bir dizeye dönüştürülmesi gereken tamsayı türünden tek bir parametre sayısını kabul eder.

 Donus degeri(Return Value): Fonksiyon, tamsayı bağımsız değişkeninin dize temsilini 8 tabanında işaretsiz bir tam sayı olarak döndürür.

Ornek: 
	import java.io.*;
 
class GFG {
    public static void main(String[] args)
    {
        // Variable Declaration
        int a;
 
        // storing normal integer value
        a = 20;
        System.out.println("Value of a: " + a);
 
        // storing octal integer value
        // just add 0 followed octal representation
        a = 024;
        System.out.println("Value of a: " + a);
 
        // convert octal representation to integer
        String s = "024";
        int c = Integer.parseInt(s, 8);
        System.out.println("Value of c: " + c);
 
        // get octal representation of a number
        int b = 50;
        System.out.println(
            "Octal Representation of the number " + b
            + " is: " + Integer.toOctalString(b));
    }
}

Kotlin`de ise octal literals Kotlin tarafindan desteklenmez.Bu yuzden ayni sayiyi ondalikli olarak tanimlamak gerekir.

val octalString = "1234"
val decimalNumber = octalString.toInt(8)  // Bu, octal 1234 sayısını ondalık              					  //668 sayısına dönüştürür.

9) "Geleneksel Notasyon" (Conventional Notation) gösterimi nasıl yapılır?

Kotlin`de değişkenlerin veya fonksiyonların isimlendirilmesi ve kodun genel düzeni gibi konularda belirli standartlar vardir.
Bunlarin bircok gosterimi olmasina ragmen bunlar kodda bizden istenene gore sekillenirler. 
Ornek: 
	const val MAX_COUNT = 8
	val mutableCollection: MutableSet<String> = HashSet()
	class C {
    private val _elementList = mutableListOf<Element>()

    val elementList: List<Element>
         get() = _elementList
}

10) Sayısal değişkenlerde alt çizgi (underscore) nasıl kullanılır? Kotlin bunu nasıl yorumlar?

Alt çizgiler, sayısal değerlerde sadece sayıların arasına yerleştirilir ve sayisal verileri adha anlasilir kilmak icin kullanilir.
Ornek:
	val craditCardNumber = 1234_5678_9012_1234L

Kotlin bu alt çizgileri sayıları yorumlamak için kullanır, ancak derleme sırasında bu alt çizgiler yok sayılır. Yani, alt çizgiler kodun okunabilirliğini artırırken, sayısal değerlerin kendisi üzerinde hiçbir etkisi yoktur.

11) `==` ile neyi karşılaştırırız? `===` ile neyi karşılaştırırız?

	`==` ile 2 nesnenin iclerindeki degeri kontrol ettirir.

val str1 = "hello"
val str2 = "hello"
val str3 = "world"

println(str1 == str2) // true, çünkü içerikleri aynı
println(str1 == str3) // false, çünkü içerikleri farklı

	`===` ile de bunlarin memorydeki(RAM`de ne kadarlik yer kapladiklarini ve hangi adreste yer kapladiklari) refereanslarini kontrol ettirir.

val array1 = intArrayOf(1, 2, 3)
val array2 = intArrayOf(1, 2, 3)
val array3 = array1

println(array1 === array2) // false, çünkü farklı bellek konumlarına sahipler
println(array1 === array3) // true, çünkü aynı bellek konumunu işaretediyorlar


12)`===` operatörü ile karşılaştırma yaparken Byte değer aralığı neden önemlidir? Kotlin bu aralığa göre neden özel bir davranış sergiler?

`===` operatoru direktmen referans turlerini karsilastirir ve bununla birlikte,`Byte` turunde bircok deger -128 ile 127 arasinda ozel bir bellege alinir.Bu araliktaki her deger icin ayni bellek adresi paylasilir.
	Ancak bu deger aralilari disindaki `byte` degerleri her zaman farkli bellek adreslerinde ayrilir.Bellekte farkli konmlarda saklanmasi gerektigi anlamina gelir.


12) Sayısal değişkenlerde hangi matematiksel operatörler kullanılabilir?

Toplama (+), Çıkarma (-), Çarpma (*), Bölme (/), Mod (%),
 Artırma (++) ,Azaltma (--)

13) Sayısal değişkenlerde hangi karşılaştırma operatörleri kullanılabilir?

Eşitlik (==),eşit değil (!=), büyüktür (>), küçüktür (<), büyük eşittir (>=),
küçük eşittir (<=)

13) Bit düzeyinde operatörler (Bitwise operators) nelerdir? Ne amaçla kullanılır? Kotlin'de bunları nasıl kullanabilirsiniz?

	Bit düzeyinde operatörler, sayıları bit seviyesinde manipüle etmek için kullanılan operatörlerdir. Bu operatörler, her bir bitin (0 veya 1) üzerinde doğrudan işlemler gerçekleştirir.

Bunlar: ve(&) , veya(|) , xor(^) , Tersi Alma (~),Kaydırma Operatörleri (<< ve >>)`dir

Bu operatörler, özellikle düşük seviyeli programlamada, veri işleme ve optimizasyon gibi alanlarda kullanılır. Örneğin, bit düzeyinde işlemler yapılarak veri sıkıştırma, veri şifreleme veya performans optimizasyonu gibi işlemler gerçekleştirilebilir.

14) Kotlin'de büyük sayılarla çalışırken hangi ek türlerden yararlanılır ve bu türlerin sınırları nelerdir?

Byte: Boyutu 8 bit olup -128 ile 127 arasında değer alır.

Short: Boyutu 16 bit olup -32768 ile 32767 arasında değer alır

Int: Boyutu 32 bit olup -2,147,483,648 (-²³¹) ile 2,147,483,647 (²³¹ -1) arasında değer alır.

Long: Boyutu 64 bit olup -9,223,372,036,854,775,808 (-²⁶³) ile 9,223,372,036,854,775,807 (²⁶³ -1) arasında değer alır.

Float: Boyutu 32 bit olup ondalıklı sayılar için kullanılır. Virgülün solu 24 bit sağı 8 bit’tir. 6–7 onlu basamaklıdır.

Double: Boyutu 64 bit olup ondalıklı sayılar için kullanılır.Virgülün solu 53 bit sağı 11 bit’tir. 15–16 onlu basamaklıdır.

15) Double ve Float değişkenler kullanılırken "yuvarlama" davranışı nasıldır? Bu nasıl değiştirilebilir?

	Kotlin'de Android geliştirirken, yuvarlama işlemleri için standart Java kütüphanesindeki Math sınıfı veya Kotlin'in kendi kütüphanesi kullanılabilir.

Örneğin, Math.round(), Math.floor(), ve Math.ceil() gibi yöntemlerle yuvarlama işlemleri gerçekleştirilebilir. Bu yöntemler, belirli bir yuvarlama davranışını sağlamak için kullanılabilir:

Math.round(): Bir double veya float değeri en yakın tam sayıya yuvarlar.
Math.floor(): Bir değeri aşağıya doğru yuvarlar.
Math.ceil(): Bir değeri yukarıya doğru yuvarlar.

	Ornek:
val number1 = 4.5
val number2 = 5.5

val roundedNumber1 = Math.round(number1) // Sonuç: 5
val floorNumber1 = Math.floor(number1) // Sonuç: 4
val ceilNumber1 = Math.ceil(number1) // Sonuç: 5

C) İşaretsiz Sayılar

1)"İşaretsiz" (Unsigned) değişkenler ne demektir? İşaretli olanlarla aralarındaki fark nedir?

"işaretsiz" (unsigned) değişkenler, yalnızca pozitif sayıları temsil edebilen veri türleridir.
	Bunlar :  UInt, UByte, UShort ve ULong

İşaretsiz değişkenlerle işaretli değişkenler arasındaki farklar şunlardır:

İşaretsiz değişkenler sadece pozitif sayıları temsil ederken, işaretli değişkenler hem pozitif hem de negatif sayıları temsil edebilirler.

İşaretsiz değişkenlerin aralığı, işaretli değişkenlerden biraz daha büyüktür, çünkü işaretsiz değişkenler negatif değerleri temsil etmezler ve bu nedenle sıfırdan başlayarak daha fazla pozitif değeri kapsarlar.

İşaretsiz değişkenlerde işaret biti yoktur. İşaretli değişkenlerde ise en sol taraftaki bit işareti olarak kullanılır.

Örnek: bir UInt değişkeni 0 ile 2^32 - 1 arasındaki pozitif tamsayı değerlerini temsil edebilirken, bir Int değişkeni -2^31 ile 2^31 - 1 arasındaki tam sayı değerlerini temsil edebilir.


2) "İşaretsiz" değişkenler nasıl bir sınıf yapısında tutulurlar? Bu neden önemlidir?

"Işaretsiz" (unsigned) değişkenler, Kotlin'de bir sınıf yapısı içinde doğrudan tutulmazlar. Bunun yerine, ilgili veri türlerinin (örneğin, UInt, UByte, UShort, ULong) önceden tanımlanmış veri türleri olduğunu belirtmek için kullanılırlar.

	Örnek, UInt bir veri türüdür ve 32-bit işaretsiz bir tamsayıyı temsil eder. Ancak, bu, bir sınıfın örneği gibi düşünülmez. UInt sadece bir veri türüdür ve doğrudan kullanılabilir.

3)"İşaretsiz" değişkenlerin harf gösterimi nasıldır?

Bu işaretsiz değişkenlerin adları, içerdikleri bit sayısına ve işaretsiz olduğunu gösteren "U" harfini eklenir.
UInt,UInt,UShort,ULong

4)"`val a1 = 42u` ve `val a2 = 0xFFFF_FFFF_FFFFu`" değişkenlerin tipleri ne olur? Neden?

	val a1 = 42u : 42u unsigend numbers anlamina gelmektedir.`UInt` olarak yorumlanir.

	val a2 = 0xFFFF_FFFF_FFFFu : `0x` ifadesi ilk olarak 16`lik tabani temsil eder ve sona eklenn`u ` sayesinde de unsigned bur number oldugun anliyoruz. bu da 64-bitlik bir tamsayının maksimum değerini (2^64 - 1) ifade eder. Bundan dolayi nu bir `ULong` turudur.

5) "İşaretsiz" "Long" harf gösterimi nasıl yapılır?

 işaretsiz 64-bit tamsayıyı temsil etmek için ULong türünü kullanilir.

6) "İşaretsiz" değişkenlerin kullanım amaçları nelerdir?

a- Bellek Yönetimi: Bellek kullanımını optimize etmek için işaretsiz değişkenler kullanılabilir. Örneğin, bir dizi pozitif indeksi temsil ederken işaretsiz tamsayılar kullanmak, bellek kullanımını azaltabilir.

	val arraySize: UInt = 100u
	val array = IntArray(arraySize.toInt())

b-Bit seviyesinde operasyonlar: Bit düzeyinde operasyonlar yaparken işaretsiz değişkenler kullanılabilir.
 Örneğin, bir verinin belli bir bit aralığındaki değerlerini işaretlemek veya işaretsiz tamsayıların bit seviyesinde operasyonlarını gerçekleştirmek için işaretsiz değişkenler kullanılabilir.

	val mask: UByte = 0b00001111u // Son 4 biti işaretle
	val value: UByte = 0b10101010u
	val maskedValue = value and mask

c-Dosya işlemleri: Dosya içeriğini işlerken veya dosya işaretçilerini yönetirken işaretsiz değişkenler kullanılabilir.
 Özellikle dosya boyutu, dosya konumu gibi değerler işaretsiz tamsayılarla temsil edilebilir

	val fileSize: ULong = 1024uL * 1024uL * 10uL // 10 MB

d-Veri işleme: Veri analizi veya işleme uygulamalarında, işaretsiz değişkenler kullanılabilir. Örneğin, piksel değerleri, işaretli olmayan renk kodları gibi pozitif değerlerle temsil edilen veriler işaretsiz değişkenlerle saklanabilir.

	val pixelColor: UInt = 0xFF00FFu


7) "İşaretsiz" değişkenlerle yapılan matematiksel işlemlerde, özellikle büyük sayılarla çalışırken karşılaşılabilecek taşma (overflow) ve taşma olmaması (underflow) durumları için Kotlin nasıl bir yönetim sağlar?

  Taşma (Overflow) Durumu:

Eğer bir işlem sonucu, ilgili işaretsiz veri türünün sınırlarını aşarsa, bu durumda taşma meydana gelir.
Taşma durumunda, işlem sonucu beklenen değerden daha küçük veya daha büyük olabilir, bu da sonucun doğru olmamasına neden olur.

  Taşma Olmaması (Underflow) Durumu:

Eğer bir işlem sonucu, işaretsiz bir veri türünün minimum değerinin altında kalırsa, bu durumda taşma olmaması (underflow) meydana gelir.
Underflow durumunda, işlem sonucu beklenen değerden daha küçük olur.

	Yontemleri:

Işlem sonuçlarını doğrudan kontrol etmek ve gerektiğinde taşma durumunu ele almasidir.

Işlemlerin sonucunu kontrol etmek

Gerektiğinde, işaretsiz değişkenlerin taşıyabileceği maksimum değeri aşmayacak şekilde işlemleri kontrol etmek için ekstra kodlama yapılabilir. Örneğin, işaretsiz değişkenlerle yapılan işlemler öncesinde, işlem sonucunun sınırlarını kontrol etmek için koşullar eklemek gibi.

8)"İşaretsiz" değişkenlerin sınırlamaları nelerdir?

 Veri türünün boyutuna bağlı olarak belirli bir bit sayısını temsil etmesi.
 Örneğin, UInt veri türü 32 bit (4 byte) uzunluğunda bir işaretsiz tamsayıyı temsil ederken, UShort veri türü 16 bit (2 byte) uzunluğunda bir işaretsiz tamsayıyı temsil eder.

 Sıfırdan başlayarak maksimum değerlerine kadar olan tam sayı değerlerini temsil ederler. Örneğin, UByte veri türü 0 ile 255 arasındaki tam sayı değerlerini alabilirken, UInt veri türü 0 ile 2^32 - 1 arasındaki tam sayı değerlerini alabilir.

 İşaretsiz değişkenlerin en küçük değeri her zaman sıfırdır. Negatif değerler içermezler ve sıfır veya pozitif değerlerle temsil edilirler.
















